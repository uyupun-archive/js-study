# 学習を進めるにあたって
本書の３章と４章を進めるにあたり, サンプルコードの実行にはpaiza.IOをお勧めする.  
paiza.IOは様々なプログラミング言語のコードをブラウザ上で実行できるWebサービスである.

使い方はまず[paiza.IO](https://paiza.io/)にアクセスし, メニューバーの左上から"New code"を選択する.  

<img src="../img/03_js_basic_knowledge/001.png" width="400">

次に, 左上のセレクトボックスから使用する言語(今回はJavaScript)を選択する.

<img src="../img/03_js_basic_knowledge/002.png" width="500">

あとは黒いテキストエリアにコードを書き, "→ Run (Ctrl-Enter)"を押すとコードが実行される.

<img src="../img/03_js_basic_knowledge/003.png" width="300">

実行結果は画面下部の白い領域に結果が表示される.  
エラーが発生した場合はエラーの内容が表示される.

<img src="../img/03_js_basic_knowledge/004.png" width="200">

# 変数の宣言と代入
プログラミング言語には, 数値や文字列などのデータに名前をつけて繰り返し使用できるようにする**変数**という機能がある.  
例えば以下のコードはJavaScriptにおける変数の宣言であり, `food`という変数を定義している.

```js
let food;
```

また, 変数には値を代入することができる.  
数学では`=`は「左辺と右辺が等しい」という意味を持つが, 多くのプログラミング言語では「右辺を左辺に代入する」という意味を持つため注意する.  

```js
let food;
food = "おすし";
```

変数の宣言と代入は同時に行えるため, 大抵の場合は以下のように変数の宣言と代入を行う.

```js
let food = "おすし";
```

上の説明では変数宣言のキーワードとして`let`を用いたが, `let`, `var`, `const`の３種類が存在する.  
このうち, `var`は最も古くからあり, 意図しない動作を作り込みやすいということから, 後に`let`と`const`が導入された.  
`let`は再代入が可能だが, `const`は再代入ができないといった特徴を持っている.

以下のコードは`let`を使って変数を定義しているため, 再代入しても問題ない.

```js
let food = "おすし";
food = "やきにく";
```

しかし, 次のコードは`const`を使って変数を定義しているため, 再代入すると`Uncaught TypeError: Assignment to constant variable.`といったエラーが発生する.

```js
const food = "おすし";
food = "やきにく";
```

そのため, 変数は基本的に,
- `var`は使用しない
- `let`は再代入する必要がある場合のみ使用する
- `const`を極力使用する

というルールを守ると良い.

変数を複数宣言する場合, `,`(カンマ)区切りで簡潔に宣言することができる.  
以下のコードでは, `foo`, `bar`, `baz`の３つの変数が宣言される.

```js
let foo, bar, baz;
```

また, constを使用する場合, 必ず初期化する必要がある.  
複数宣言する場合, 以下のコードのように宣言する.

```js
const foo = "foo", bar = "bar", baz = "baz"
```

変数は半角アルファベット(`a`〜`z`, `A`〜`Z`), 数字(`0`〜`9`)アンダースコア(`_`), ダラー(`$`)を組み合わせた文字を使用できるが, 先頭に数字を使用することはできない.  
また, 予約後を変数に使用することはできない.  
ひらがなや漢字、絵文字の一部も使えるが環境によっては扱いにくいのでオススメはしない.

```js
let $Foo_334;
```

変数を記述する場合, キャメルケースを使用することをオススメする.

```js
const foodName = "おすし";
```

# データ型とリテラル
JavaScriptは動的型付け言語であるため, 静的型付け言語のような変数の型はない.  
しかし, 値の型は存在する.  
これらの値のことを**データ型**という.
 
データ型は, **プリミティブ型**と**オブジェクト**の2つに分類される.  
プリミティブ型は, 真偽値や数値などの基本的な値の型である.  
一度作成したらその値自体を変更できないというイミュータブルの特性を持つ.  
一方, プリミティブ型ではないものをオブジェクトという.  
一度作成した後もその値自体を変更できるためミュータブルの特性を持つ.

データ型は, 細かく分けると, 6つのプリミティブ型とオブジェクトからなる.  
以下に詳細を表示する.

プリミティブ型

|型名|説明|
|:--|:--|
|真偽値(Boolean)|`true`または`false`のデータ型|
|数値(Number)|`35`や`42.195`などの数値のデータ型|
|文字列(String)|`"foo"`や`"bar"`などの文字列のデータ型|
|undefined|値が未定義であることを意味するデータ型|
|null|値が存在しないことを意味するデータ型|
|シンボル(Symbol)|ES6から追加.<br>一意で不変な値のデータ型|

オブジェクト

- プリミティブ型以外のデータ
- オブジェクト、配列、関数、正規表現、Dateなど

プリミティブ型やオブジェクトは, **リテラル**を使用することで簡単に定義できるようになる.  
リテラルとは, プログラム上で数値や文字列など、直接記述した内容がそのデータ型の値を書ける構文として定義したものである.  
例えば, `"`と`"`で囲んだ範囲が文字列リテラルであり, 文字列型のデータを表している.  
リテラル表現がない場合, その値を作る関数に引数を渡して作成する.  

以下の4つのプリミティブ型とオブジェクトに関しては, リテラル表現が用意されている.

- 真偽値
- 数値
- 文字列
- null
- オブジェクト
- 配列
- 正規表現

これらのリテラルについて, 詳しく知りたい方は, [JavaScript Primer 第一部 データ型とリテラル](https://jsprimer.net/basic/data-type/)を参考にするとよい.

# 演算子
演算子はよく利用する演算処理を記号などで表現したものである.  
演算子は演算する対象を持ち, この対象のことを**被演算子(オペランド)**という.  
オペランドの数に応じて, 単項演算子, 二項演算子があり, 同じ記号を使用することがあるため, 呼び方を変えている.  

// TODO: どの演算子の例を載せるか

# 型変換
型変換には, 明示的な型変換と暗黙的な型変換がある.  
例えば, 厳密等価演算子(===)ではなく, 等価演算子(==)を使用して値を比較すると, 暗黙的な型変換が行われる.
以下のコードでは, 暗黙的な型変換によって結果は`true`になる.

```js
console.log(1 == "1");
```

このように, 暗黒的な型変換は意図しない結果となるため, 型変換をする場合, 明示的な型変換を行う.  
以下のコードでは, Booleanコンストラクタ関数を使用し, 任意の値を真偽値に変換している.

```js
Boolean("string"); // => true
Boolean(1); // => true
Boolean({}); // => true
Boolean(0); // => false
Boolean(""); // => false
Boolean(null); // => false
```

どの値が`true`でどの値が`false`になるかは以下のルールによって決められる.

- falsyな値はfalseになる
- falsyでない値はtrueになる

falsyな値とは次の6種類の値のことをいう.

- false
- undefined
- null
- 0
- NaN
- ""

型変換について詳しく調べたい方は, [JavaScript Primer 第一部 暗黙的な型変換](https://jsprimer.net/basic/implicit-coercion/)を参考にするとよい.

# コメント
コメントは, 一行コメントと複数行コメントの2種類の書き方がある.  

```js
// 一行コメント

/*
複数行コメント
複数行コメント
*/
```

また, ES6から後方互換性のための仕様として, **HTML-likeコメント**が追加された.  
HTML-likeコメントは, ブラウザの実装に合わせた後方互換性のための仕様として定義されている.  
JavaScriptをサポートしていないブラウザでは、`<script>`タグを正しく認識できないため, 書かれたコードがブラウザに表示されてしまう.  
その回避策として, HTML-likeコメントを使用する.  
しかし, 現在は`<script>`タグをサポートしていないブラウザはないため, HTML-likeコメントは不要である.

```html
<script>
<!--
console.log("hoge");
-->
</script>
```

# 配列とオブジェクト
配列は, 値に順序をつけて格納できるオブジェクトである.  
配列に格納したそれぞれの値のことを**要素**、それぞれの要素の位置のことを**インデックス**という.  
インデックスは, 先頭の要素から`0`,`1`,`2`と`0`から始まる.  
また, 配列は可変長であるため, 後から配列へ要素を追加したり削除したりできる.  
配列の作成は, 以下のコードのように配列リテラル`[`と`]`の中に要素をカンマ区切りで記述する.

```js
const array = [];

const numbers = [1, 2, 3];

// 2次元配列（配列の配列）
const matrix = [
    ["a", "b"],
    ["c", "d"]
];
```

作成した配列から要素を読み取る場合, `配列[インデックス]`と記述する.  
また, 2次元配列も同様にアクセスできる.  
配列のインデックスは, `0`以上`2^32 - 1`未満の整数である.

```js
const numbers = [1, 2, 3];
console.log(numbers[0]); // => 1

const matrix = [
    ["a", "b"],
    ["c", "d"]
];
console.log(numbers[0][0]); // => "a"
```

オブジェクトは, プロパティの集まりである.  
プロパティとは, 名前(キー)と値が対になったものである.  
プロパティのキーには文字列と`Symbol`が利用し, 値には任意のデータを指定する.  
また, 1つのオブジェクトは複数のプロパティを持てる.

オブジェクトはオブジェクトリテラル`{}`を使用し作成する.

```js
const obj = {};
```

初期値を持つオブジェクトは, オブジェクトリテラルの中にキーと値をコロンで区切り記述する.  
また, 複数の値を宣言するには, カンマで区切り記述する.  
プロパティ名はクオートを省略できるが, ハイフンを含むプロパティ名は省略できない.

```js
const obj = {
  "key": "value",
  foo: "foo",
  your-name: "name"  // NG
};
```

配列, オブジェクト, オブジェクトのコピー(shallow copy, deep copy)

# 制御構文
## 条件分岐
if文やswitch文を使用することで, 条件分岐を記述できる.  
条件分岐を使用することで, 特定の条件を満たすかどうかで実行する処理を変更できる.

### if文
以下のコードは, if文の基本形である.  
条件式の評価結果が`true`であるならば, 処理が実行される.

```js
if (条件式) {
  処理;
}
```

次のコードは, 条件式が`true`であるため, 処理が実行される.

```js
if (true) {
  console.log("この処理は実行される");
}
```

また, if文内の処理が1行の場合, `{}`を省略できる.

```js
if (true)
  console.log("この処理は実行される");
```

if文は条件式に比較演算子などを使用し, その比較結果によって処理を分岐するためによく使用される.

```js
const num = 60;
if (num > 50) {
  console.log("numは50より大きな値");
}
```

複数の条件分岐を記述する場合, if文に続けてelse if文やelse文を使用する.

```js
const num = 60;
if (num > 100) {
  console.log("numは100より大きな値");
}
else if (num > 50) {
  console.log("numは50より大きな値");
}
else {
  console.log("numは50以下の値");
}
```

### switch文
switch文は式の評価結果が, 指定した値である場合に実行する処理を並べて記述する.  

```js
const num = 2;
switch (num) {
  case 1:
    console.log("numの値は1");
    break;
  case 2:
    console.log("numの値は2");
    break;
  case 3:
    console.log("numの値は3");
    break;
  default:
    console.log("numの値は1, 2, 3以外");
    break;
}
```

`default`を使用することで, 式の評価結果に関わらず, 処理が実行される.  
上記のコードはbreak文を使用しているため, `default`内の処理は実行されない.  
break文がない場合, switch文は最後まで式の評価結果と指定した値を比較し続ける.

## 反復処理
for文やwhile文などを使用することで反復処理を記述できる.

### for
for文は繰り返す範囲を指定した反復処理を記述できる.

```js
for (初期化式; 条件式; 増分式) {
    処理;
}
```

for文の実行フローは次のようになる.

1. 初期化式で変数宣言
2. 条件式の評価結果が`true`なら3へ, `false`なら終了
3. 処理を実行
4. 増分式で変数を更新
5. 2へ戻る

```js
let total = 0;

for (let i = 0; i < 10; i++) {
  total += i + 1;
}
console.log(total); // => 55
```

if, for, for in, for of, while(オマケ), forEach, break, continue, return

# 様々な関数
即時関数(滅びた), 関数宣言, 関数式, アロー関数, this

# undefined, Null, NaN
